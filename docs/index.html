<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>functional documentation</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>functional</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Fields">Fields</a></li>
<li><a href="#Class_Iterator">Class Iterator </a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>functional</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>functional</code></h1>
<p><h2>A module for functional programming utils.</h2>
 <h3>About the module</h3>
 <p style="text-align: justify">This module seeks to provide some utility functions and structures
 which are too verbose in vanilla lua, in particular with regards to iteration
 and inline function definition.</p>
 <p style="text-align: justify">The module is writen completely in vanilla lua,
 with no dependencies on external packages&period; This was a decision made for
 portability, and has drawbacks&period; Since none of this was written as a C binding, it is not
 as performant as it could be.</p>
 <p style="text-align: justify">For example, <a href="https://github.com/luafun/luafun">luafun</a>
 is "high-performance functional programming library for Lua designed with
 <a href="http://luajit.org/luajit.html">LuaJIT</a>'s trace compiler in mind"
 &period; If your environment allows you to use LuaJIT and performance is a
 concern, perhaps luafun will be more suited for your needs.</p>
 <p style="text-align: justify; background: #eeeeee; border: 1px solid black;
 margin-left: 15%; margin-right: 15%; padding: 10px;">
 The motivation behind this module is, again, portability&period;
 If you want to embed this code on a webpage, or use it in some weird
 system for which a C binding wouldn't work, this project is aimed
 at you.</p>
 <h3>Definitions</h3>
 <h4>Array</h4>
 <p style="text-align: justify">As lua doesn't have a dedicated array
 type, the word "array" in this document referes to a table with contiguous
 non-<code>nil</code> values starting at index <code>1</code>.</p>
 <h4>Iterable</h4>
 <p>An <code>iterable</code> refers to either of:
 <ul>
 <li> An array (see above); or </li>
 <li> An instance of <code>Iterator</code>.</p>
<p> </li>
 </ul></p></p>
    <h3>Info:</h3>
    <ul>
        <li><strong>Copyright</strong>: 2021</li>
        <li><strong>Release</strong>: 1.5.1</li>
        <li><strong>License</strong>: MIT</li>
        <li><strong>Author</strong>: William Quelho Ferreira</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#iterate">iterate (iterable)</a></td>
	<td class="summary">Create an <code><a href="index.html#Iterator">Iterator</a></code> for the <code>iterable</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#counter">counter ()</a></td>
	<td class="summary">Iterate over the naturals starting at 1.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#range">range ([start=1], stop[, step=1])</a></td>
	<td class="summary">Create an integer iterator that goes from <code>start</code> to <code>stop</code>, <code>step</code>-wise.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#filter">filter (iterable, predicate)</a></td>
	<td class="summary">Select only values which match the predicate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#map">map (iterable, mapping)</a></td>
	<td class="summary">Map values into new values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#reduce">reduce (iterable, reducer, initial_value)</a></td>
	<td class="summary">Collapse values into a single value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#foreach">foreach (iterable, func)</a></td>
	<td class="summary">Apply a function to all values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#last">last (iterable)</a></td>
	<td class="summary">Return the last value of the given iterable.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#take">take (iterable, n)</a></td>
	<td class="summary">Iterate over the <code>n</code> first values and stop.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#skip">skip (iterable, n)</a></td>
	<td class="summary">Iterate over the values, starting at the <code>(n+1)</code>th one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#every">every (iterable, n)</a></td>
	<td class="summary">Take 1 value every <code>n</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#any">any (iterable, predicate)</a></td>
	<td class="summary">Checks if any values evaluate to <code>true</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#all">all (iterable, predicate)</a></td>
	<td class="summary">Checks if all values evaluate to <code>true</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#zip">zip ()</a></td>
	<td class="summary">Iterate over two iterables simultaneously.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#packed_zip">packed_zip ()</a></td>
	<td class="summary">Iterate over two iterables simultaneously.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#concat">concat ()</a></td>
	<td class="summary">Concatenate two iterables into an Iterator.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#nop">nop ()</a></td>
	<td class="summary">Does nothing.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#identity">identity (...)</a></td>
	<td class="summary">Returns its arguments in the same order.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#lambda">lambda (expr[, env={}])</a></td>
	<td class="summary">Create a lambda function from a given expression string.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#to_array">to_array (iterable)</a></td>
	<td class="summary">Return an array version of the <code>iterable</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#to_coroutine">to_coroutine (iterable)</a></td>
	<td class="summary">Create a <code>coroutine</code> that yields the values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#negate">negate (predicate)</a></td>
	<td class="summary">Create a negated function of <code>predicate</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#compose">compose (f1, f2, ...)</a></td>
	<td class="summary">Create a function composition from the given functions.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#bind">bind (func, ...)</a></td>
	<td class="summary">Create a function with bound arguments.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#curry">curry (func, levels)</a></td>
	<td class="summary">Curries a function by the given amount of arguments.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#dict">dict (t)</a></td>
	<td class="summary">Create a function that accesses <code>t</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#indexer">indexer (k)</a></td>
	<td class="summary">Create a function that accesses the key <code>k</code> for any table.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#bind_self">bind_self (t, k, ...)</a></td>
	<td class="summary">Create a bound function whose first argument is <code>t</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#constant">constant (value)</a></td>
	<td class="summary">Create a function that always returns the same value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#import">import ([env=_G])</a></td>
	<td class="summary">Import <code><a href="index.html#Iterator">Iterator</a></code>, <code><a href="index.html#lambda">lambda</a></code>, and commonly used functions into a given scope.</td>
	</tr>
</table>
<h2><a href="#Fields">Fields</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#_VERSION">_VERSION</a></td>
	<td class="summary">Module version.</td>
	</tr>
</table>
<h2><a href="#Class_Iterator">Class Iterator </a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#Iterator.over">Iterator.over (iterable)</a></td>
	<td class="summary">Iterate over the given <code>iterable</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:next">Iterator:next ()</a></td>
	<td class="summary">Retrieve the next element from the iterator, if any.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator.counter">Iterator.counter ()</a></td>
	<td class="summary">Iterate over the naturals starting at 1.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator.range">Iterator.range ([start=1], stop[, step=1])</a></td>
	<td class="summary">Create an integer iterator that goes from <code>start</code> to <code>stop</code>, <code>step</code>-wise.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator.from">Iterator.from (func, is, var)</a></td>
	<td class="summary">Iterate over the function's returned values upon repeated calls.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator.packed_from">Iterator.packed_from (func, is, var)</a></td>
	<td class="summary">Iterate over the function's returned values (packed into a table) upon repeated calls.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator.from_coroutine">Iterator.from_coroutine (co)</a></td>
	<td class="summary">Iterate over the <code>coroutine</code>'s yielded values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator.clone">Iterator.clone (iterable)</a></td>
	<td class="summary">Nondestructively return an independent iterable from the given one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:filter">Iterator:filter (predicate)</a></td>
	<td class="summary">Select only values which match the predicate.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:map">Iterator:map (mapping)</a></td>
	<td class="summary">Map values into new values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:reduce">Iterator:reduce (reducer, initial_value)</a></td>
	<td class="summary">Collapse values into a single value.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:foreach">Iterator:foreach (func)</a></td>
	<td class="summary">Apply a function to all values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:last">Iterator:last ()</a></td>
	<td class="summary">Consume the iterator and retrieve the last value it produces.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:take">Iterator:take (n)</a></td>
	<td class="summary">Iterate over the <code>n</code> first values and stop.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:take_while">Iterator:take_while (predicate)</a></td>
	<td class="summary">Iterate while <code>predicate</code> is <code>true</code> and stop.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:take_last">Iterator:take_last (n)</a></td>
	<td class="summary">Consume the iterator and produce its <code>n</code> last values in order.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:take_until">Iterator:take_until (predicate)</a></td>
	<td class="summary">Iterate while <code>predicate</code> is <code>false</code> and stop.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:skip">Iterator:skip (n)</a></td>
	<td class="summary">Iterate over the values, starting at the <code>(n+1)</code>th one.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:skip_while">Iterator:skip_while (predicate)</a></td>
	<td class="summary">Iterate over the values, starting whenever <code>predicate</code> becomes <code>false</code> for the first time.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:skip_until">Iterator:skip_until (predicate)</a></td>
	<td class="summary">Iterate over the values, starting whenever <code>predicate</code> becomes <code>true</code> for the first time.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:every">Iterator:every (n)</a></td>
	<td class="summary">Take 1 value every <code>n</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:any">Iterator:any (predicate)</a></td>
	<td class="summary">Checks if any values evaluate to <code>true</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:all">Iterator:all (predicate)</a></td>
	<td class="summary">Checks if all values evaluate to <code>true</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:count">Iterator:count (predicate)</a></td>
	<td class="summary">Counts how many values evaluate to <code>true</code>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:zip">Iterator:zip (other)</a></td>
	<td class="summary">Iterate over two iterables simultaneously.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:packed_zip">Iterator:packed_zip (other)</a></td>
	<td class="summary">Iterate over two iterables simultaneously, giving their values as an array.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:concat">Iterator:concat (other)</a></td>
	<td class="summary">Append elements from `other` after this iterator has been exhausted.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:to_array">Iterator:to_array ()</a></td>
	<td class="summary">Create an array out of the <code><a href="index.html#Iterator">Iterator</a></code>'s values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:to_coroutine">Iterator:to_coroutine ()</a></td>
	<td class="summary">Create a <code>coroutine</code> that yields the values.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Iterator:is_complete">Iterator:is_complete ()</a></td>
	<td class="summary">Check whether or not the iterator is done.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "iterate"></a>
    <strong>iterate (iterable)</strong>
    </dt>
    <dd>
    Create an <code><a href="index.html#Iterator">Iterator</a></code> for the <code>iterable</code>.
 <p>Equivalent to <pre>Iterator.over(iterable)</pre>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "counter"></a>
    <strong>counter ()</strong>
    </dt>
    <dd>
    Iterate over the naturals starting at 1.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the counter
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#Iterator:take">Iterator:take</a></li>
         <li><a href="index.html#Iterator:skip">Iterator:skip</a></li>
         <li><a href="index.html#Iterator:every">Iterator:every</a></li>
    </ul>


</dd>
    <dt>
    <a name = "range"></a>
    <strong>range ([start=1], stop[, step=1])</strong>
    </dt>
    <dd>
    Create an integer iterator that goes from <code>start</code> to <code>stop</code>, <code>step</code>-wise.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">start</span>
            <span class="types"><span class="type">integer</span></span>
         the start of the integer range
         (<em>default</em> 1)
        </li>
        <li><span class="parameter">stop</span>
            <span class="types"><span class="type">integer</span></span>
         the end of the integer range (inclusive)
        </li>
        <li><span class="parameter">step</span>
            <span class="types"><span class="type">integer</span></span>
         the difference between consecutive elements
         (<em>default</em> 1)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#Iterator.range">Iterator.range</a>
    </ul>


</dd>
    <dt>
    <a name = "filter"></a>
    <strong>filter (iterable, predicate)</strong>
    </dt>
    <dd>
    Select only values which match the predicate.
 <p>Equivalent to <pre>iterate(iterable):filter(predicate)</pre>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be filtered
        </li>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the function to evaluate for each value
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the filtering <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#iterate">iterate</a></li>
         <li><a href="index.html#Iterator:filter">Iterator:filter</a></li>
    </ul>


</dd>
    <dt>
    <a name = "map"></a>
    <strong>map (iterable, mapping)</strong>
    </dt>
    <dd>
    Map values into new values.
 <p>Equivalent to <pre>iterate(iterable):map(mapping)</pre>.</p>
 <p>Please note that at no point during iteration may
 the <code>mapping</code> function return <code>nil</code>
 as its first value.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be mapped
        </li>
        <li><span class="parameter">mapping</span>
            <span class="types"><span class="type">function</span></span>
         the function to evaluate for each value
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the mapping <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#iterate">iterate</a></li>
         <li><a href="index.html#Iterator:map">Iterator:map</a></li>
    </ul>


</dd>
    <dt>
    <a name = "reduce"></a>
    <strong>reduce (iterable, reducer, initial_value)</strong>
    </dt>
    <dd>
    Collapse values into a single value.
 <p>Equivalent to <pre>iterate(iterable):reduce(reducer, initial_value)</pre>.</p>
 <p>A reducer is a function of the form
 <pre>function(accumulated_value, new_value)</pre>
 which returns the reducing or "accumulation" of
 <code>accumulated_value</code> and <code>new_value</code></p>
 <p>The definition of "reducing" is flexible, and a few common examples
 include sum and concatenation.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be collapsed
        </li>
        <li><span class="parameter">reducer</span>
            <span class="types"><span class="type">reducer</span></span>
         the collapsing function
        </li>
        <li><span class="parameter">initial_value</span>
         the initial value passed to the <code>reducer</code>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the accumulation of all values
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#iterate">iterate</a></li>
         <li><a href="index.html#Iterator:reduce">Iterator:reduce</a></li>
    </ul>


</dd>
    <dt>
    <a name = "foreach"></a>
    <strong>foreach (iterable, func)</strong>
    </dt>
    <dd>
    Apply a function to all values.
 <p>Equivalent to <pre>iterate(iterable):foreach(func)</pre>.</p>
 <p>The main difference between <code><a href="index.html#foreach">foreach</a></code> and
 <code><a href="index.html#map">map</a></code> is that <code>foreach</code> ignores the
 return value(s) of its function, while map uses them and has restrictions
 on what it can return.</p>
 <p>Another important difference is that <code><a href="index.html#map">map</a></code>
 is a lazy evaluator, while <code><a href="index.html#foreach">foreach</a></code> iterates over
 its values immediately.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
        <li><span class="parameter">func</span>
            <span class="types"><span class="type">function</span></span>
         the function to apply for each value
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#iterate">iterate</a></li>
         <li><a href="index.html#Iterator:foreach">Iterator:foreach</a></li>
    </ul>


</dd>
    <dt>
    <a name = "last"></a>
    <strong>last (iterable)</strong>
    </dt>
    <dd>
    Return the last value of the given iterable.
 <p>If <code>iterable</code> is an iterator, this call is equivalent to <code>iterable:last()</code>.
 Otherwise, this call accesses the last element in the array.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the sequence whose last element is to be accessed
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the last element in the sequence
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#Iterator:last">Iterator:last</a>
    </ul>


</dd>
    <dt>
    <a name = "take"></a>
    <strong>take (iterable, n)</strong>
    </dt>
    <dd>
    Iterate over the <code>n</code> first values and stop.
 <p>Equivalent to <pre>iterate(iterable):take(n)</pre>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">integer</span></span>
         amount of values to take
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#iterate">iterate</a></li>
         <li><a href="index.html#Iterator:take">Iterator:take</a></li>
    </ul>


</dd>
    <dt>
    <a name = "skip"></a>
    <strong>skip (iterable, n)</strong>
    </dt>
    <dd>
    Iterate over the values, starting at the <code>(n+1)</code>th one.
 <p>Equivalent to <pre>iterate(iterable):skip(n)</pre>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">integer</span></span>
         amount of values to skip
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#iterate">iterate</a></li>
         <li><a href="index.html#Iterator:skip">Iterator:skip</a></li>
    </ul>


</dd>
    <dt>
    <a name = "every"></a>
    <strong>every (iterable, n)</strong>
    </dt>
    <dd>
    Take 1 value every <code>n</code>.
 <p>Equivalent to <pre>iterate(iterable):every(n)</pre>.</p>
 <p>The first value is always taken.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">integer</span></span>
         one more than the number of skipped values
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#Iterator:every">Iterator:every</a></li>
         <li><a href="index.html#iterate">iterate</a></li>
         <li><a href="index.html#skip">skip</a></li>
    </ul>


</dd>
    <dt>
    <a name = "any"></a>
    <strong>any (iterable, predicate)</strong>
    </dt>
    <dd>
    Checks if any values evaluate to <code>true</code>.
 <p>Equivalent to <pre>iterate(iterable):any(predicate)</pre>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the function to evaluate for each value,
 defaults to <pre>not (value == nil or value == false)</pre>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        <code>true</code> if and only if at least one of the
 values evaluate to <code>true</code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#Iterator:any">Iterator:any</a></li>
         <li><a href="index.html#iterate">iterate</a></li>
    </ul>


</dd>
    <dt>
    <a name = "all"></a>
    <strong>all (iterable, predicate)</strong>
    </dt>
    <dd>
    Checks if all values evaluate to <code>true</code>.
 <p>Equivalent to <pre>iterate(iterable):all(predicate)</pre>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the function to evaluate for each value,
 defaults to <pre>not (value == nil or value == false)</pre>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        <code>true</code> if and only if all of the
 values evaluate to <code>true</code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#Iterator:all">Iterator:all</a></li>
         <li><a href="index.html#iterate">iterate</a></li>
    </ul>


</dd>
    <dt>
    <a name = "zip"></a>
    <strong>zip ()</strong>
    </dt>
    <dd>
    Iterate over two iterables simultaneously.





    <h3>See also:</h3>
    <ul>
         <a href="index.html#Iterator:zip">Iterator:zip</a>
    </ul>


</dd>
    <dt>
    <a name = "packed_zip"></a>
    <strong>packed_zip ()</strong>
    </dt>
    <dd>
    Iterate over two iterables simultaneously.





    <h3>See also:</h3>
    <ul>
         <a href="index.html#Iterator:packed_zip">Iterator:packed_zip</a>
    </ul>


</dd>
    <dt>
    <a name = "concat"></a>
    <strong>concat ()</strong>
    </dt>
    <dd>
    Concatenate two iterables into an Iterator.





    <h3>See also:</h3>
    <ul>
         <a href="index.html#Iterator:concat">Iterator:concat</a>
    </ul>


</dd>
    <dt>
    <a name = "nop"></a>
    <strong>nop ()</strong>
    </dt>
    <dd>
    Does nothing.







</dd>
    <dt>
    <a name = "identity"></a>
    <strong>identity (...)</strong>
    </dt>
    <dd>
    Returns its arguments in the same order.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         the values to be returned
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the given values
    </ol>




</dd>
    <dt>
    <a name = "lambda"></a>
    <strong>lambda (expr[, env={}])</strong>
    </dt>
    <dd>
    Create a lambda function from a given expression string.
 <p><em>DO NOT USE THIS WITH UNTRUSTED OR UNKNOWN STRINGS!</em></p>
 <p>This is meant to facilitate writing inline functions, since
 the vanilla Lua way is very verbose.</p>
 <p>The expression must abide by several criteria:</p>
 <ul>
 <li>It <em>must</em> be an expression that would make sense if put inside parenthesis in vanilla Lua;
 <li>It <em>must not</em> start with the word "return";
 <li>It <em>must not</em> contain any newlines (if you need multiple lines, it shouldn't be a lambda);
 <li>It <em>must not</em> contain comments, or the sequence <code>--</code> inside strings;
 <li>It <em>must not</em> contain the words "end" or "_ENV", <em>even inside strings</em>.
 </ul>
 <p>If any of the above criteria fail to be met, the lambda creator will error.</p>
 <p>Even with these measures, it is still not safe to create lambdas from untrusted sources.
 These are attempts to prevent the most basic and naïve attacks, as well as mistakes on the part
 of the programmer.</p>
 <p>Inside the expression, the names <code>_1</code>, <code>_2</code>, <code>_3</code>, <code>_4</code>,
 <code>_5</code>, <code>_6</code>, <code>_7</code>, <code>_8</code>, and <code>_9</code> can be used
 to refer to the arguments given to the function. Alternatively, the letters <code>a</code> through
 <code>i</code> can also be used. For the first 3 arguments, an additional alias exists: <code>x</code>,
 <code>y</code>, and <code>z</code>. And lastly, for the first argument, simply <code>_</code> or <code>v</code> may be used.</p>
 <p>The lambda function is isolated into a sandboxed environment. That means it cannot read or write
 to local or global variables. If the function must access variables that are not given as arguments,
 you must add them to the <code>env</code> table. Setting a key <code>k</code> of that table to a
 value <code>v</code> will provide the given lambda with a variable called <code>k</code>
 with value <code>v</code>.</p>
 <p>When using <code>env</code> to overwrite the parameter name aliases (i.e., <code>a-i</code>,
 <code>x-z</code>, and <code>v</code>), it is important that the new value is neither <code>nil</code> nor <code>false</code>.
 Due to the internal mechanism used to detect when to set these aliases, having a falsy value counts
 as not being defined. In order to minimize debugging and frustration in this niche use case of <code>env</code>,
 the lambda will not be created and instead it will error stating which alias would fail to be set.</p>
 <p>Examples:</p>
 <ul>
 <li> <code>add = f.lambda "_1 + _2" -- adds its 2 arguments</code>
 <li> <code>add = f.lambda "a + b" -- same as above</code>
 <li> <code>add = f.lambda "x + y" -- same as above</code>
 <li> <code>inc = f.lambda "_1 + 1" -- adds 1 to its argument</code>
 <li> <code>inc = f.lambda "a + 1" -- same as above</code>
 <li> <code>inc = f.lambda "x + 1" -- same as above</code>
 <li> <code>inc = f.lambda "_ + 1" -- same as above</code>
 <li> <code>double_plus_one = f.lambda("_ + inc(_)", {inc = inc}) -- lets lambda "see" inc exists</code>
 <li> <code>valid_env = f.lambda("v + 2*i", {i = complex.i}) -- defines i as complex.i instead of an alias for _9</code>
 <li> <code>invalid_env = f.lambda("v and not f", {f = false}) -- ERROR! f cannot be assigned a falsy value because it's an alias for _6</code>
 </ul>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">expr</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.3/manual.html#6.4">string</a></span>
         the expression to be made into a function
        </li>
        <li><span class="parameter">env</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.3/manual.html#6.6">table</a></span>
         the function environment
         (<em>default</em> {})
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        the generated function
    </ol>




</dd>
    <dt>
    <a name = "to_array"></a>
    <strong>to_array (iterable)</strong>
    </dt>
    <dd>
    Return an array version of the <code>iterable</code>.
 <p>If <code>iterable</code> is an array, return itself.</p>
 <p>If <code>iterable</code> is an <code><a href="index.html#Iterator">Iterator</a></code>,
 return <pre>iterable:to_array()</pre>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to make an array out of
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">array</span></span>
        the array
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#Iterator:to_array">Iterator:to_array</a></li>
         <li><a href="index.html#iterate">iterate</a></li>
    </ul>


</dd>
    <dt>
    <a name = "to_coroutine"></a>
    <strong>to_coroutine (iterable)</strong>
    </dt>
    <dd>
    Create a <code>coroutine</code> that yields the values.
 of the <code>iterable</code>.
 <p>Equivalent to <pre>iterate(iterable):to_coroutine()</pre>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">thread</span></span>
        The new <code>coroutine</code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#Iterator:to_coroutine">Iterator:to_coroutine</a></li>
         <li><a href="index.html#iterate">iterate</a></li>
    </ul>


</dd>
    <dt>
    <a name = "negate"></a>
    <strong>negate (predicate)</strong>
    </dt>
    <dd>
    Create a negated function of <code>predicate</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the function to be negated
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">predicate</span></span>
        the inverted predicate
    </ol>




</dd>
    <dt>
    <a name = "compose"></a>
    <strong>compose (f1, f2, ...)</strong>
    </dt>
    <dd>
    Create a function composition from the given functions.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">f1</span>
            <span class="types"><span class="type">function</span></span>
         the outermost function of the composition
        </li>
        <li><span class="parameter">f2</span>
            <span class="types"><span class="type">function</span></span>
         the second outermost function of the composition
        </li>
        <li><span class="parameter">...</span>
            <span class="types"><span class="type">function...</span></span>
         any further functions to add to the composition,
 in order
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        the composite function
    </ol>




</dd>
    <dt>
    <a name = "bind"></a>
    <strong>bind (func, ...)</strong>
    </dt>
    <dd>
    Create a function with bound arguments.
 <p>The bound function returned will call <code>func</code>
 with the arguments passed on to its creation.</p>
 <p>If more arguments are given during its call, they are
 appended to the original ones.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">func</span>
            <span class="types"><span class="type">function</span></span>
         the function to create a binding of
        </li>
        <li><span class="parameter">...</span>
         the arguments to bind to the function.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        the bound function
    </ol>




</dd>
    <dt>
    <a name = "curry"></a>
    <strong>curry (func, levels)</strong>
    </dt>
    <dd>
    Curries a function by the given amount of arguments.
 <p>Currying is, in simple terms, transforming a function <code>f</code> which is used as:</p>
 <pre>res = f(x, y, z)</pre>
 <p>Into a function <code>g</code> which is used as:</p>
 <pre>h = g(x); i = h(y); res = i(z)</pre>
 <p>Or, chaining all the calls into a single statement:</p>
 <pre>res = g(x)(y)(z)</pre>
 <p>You can read more about currying in the <a href="https://en.wikipedia.org/wiki/Currying">Wikipedia
 page on currying</a></p>
 <p>In all levels except the deepest, any arguments past the first are ignored. In the deepest
 level, though, they are passed along to the function as normal. For example:</p>
 <pre>
local function func(a, b, c, d) return a * b * c * d end
local cfunc = f.curry(func, 3) -- 3 levels deep curry
local c1 = cfunc(1) -- binds a = 1; 2 levels left after the call
local c2 = c1(2, 3) -- binds b = 2, drops the 3; 1 level left after the call
local res = c2(4, 5) -- calls w/ c = 4 & d = 5; this was the last level</pre>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">func</span>
            <span class="types"><span class="type">function</span></span>
         the function to be curried
        </li>
        <li><span class="parameter">levels</span>
            <span class="types"><span class="type">integer</span></span>
         the number of levels to curry for
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        the curried function
    </ol>




</dd>
    <dt>
    <a name = "dict"></a>
    <strong>dict (t)</strong>
    </dt>
    <dd>
    Create a function that accesses <code>t</code>.
 <p>Creates a function that reads from <code>t</code>. The new
 function's argument is used as the key to index <code>t</code>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.3/manual.html#6.6">table</a></span>
         the table to be indexed
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        the dictionary function
    </ol>




</dd>
    <dt>
    <a name = "indexer"></a>
    <strong>indexer (k)</strong>
    </dt>
    <dd>
    Create a function that accesses the key <code>k</code> for any table.
 <p>The argument passed to the returned function is used as the table
 <code>t</code> to be accessed. The value of <code>t[k]</code>
 is returned.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">k</span>
         the key to access
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        the table indexer
    </ol>




</dd>
    <dt>
    <a name = "bind_self"></a>
    <strong>bind_self (t, k, ...)</strong>
    </dt>
    <dd>
    Create a bound function whose first argument is <code>t</code>.
 <p>Particularly useful to pass a method as a function.</p>
 <p>Equivalent to <pre>bind(t[k], t, ...)</pre>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">t</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.3/manual.html#6.6">table</a></span>
         the table to be accessed
        </li>
        <li><span class="parameter">k</span>
         the key to be accessed
        </li>
        <li><span class="parameter">...</span>
         further arguments to bind to the function
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        the binding for <code>t[k]</code>
    </ol>




</dd>
    <dt>
    <a name = "constant"></a>
    <strong>constant (value)</strong>
    </dt>
    <dd>
    Create a function that always returns the same value.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">value</span>
         the constant to be returned
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        the constant function
    </ol>




</dd>
    <dt>
    <a name = "import"></a>
    <strong>import ([env=_G])</strong>
    </dt>
    <dd>
    Import <code><a href="index.html#Iterator">Iterator</a></code>, <code><a href="index.html#lambda">lambda</a></code>, and commonly used functions into a given scope.
 <p>Upon calling this, the following module entries will be
 added to the given environment. If <code>env</code> is <code>nil</code>,
 <code>_G</code> (global scope) is assumed.</code></p>
 <ul>
 <li> <a href="index.html#Iterator">Iterator</a> </li>
 <li> <a href="index.html#iterate">iterate</a> </li>
 <li> <a href="index.html#filter">filter</a> </li>
 <li> <a href="index.html#map">map</a> </li>
 <li> <a href="index.html#reduce">reduce</a> </li>
 <li> <a href="index.html#foreach">foreach</a> </li>
 <li> <a href="index.html#take">take</a> </li>
 <li> <a href="index.html#skip">skip</a> </li>
 <li> <a href="index.html#every">every</a> </li>
 <li> <a href="index.html#any">any</a> </li>
 <li> <a href="index.html#all">all</a> </li>
 <li> <a href="index.html#zip">zip</a> </li>
 <li> <a href="index.html#packed_zip">packed_zip</a> </li>
 <li> <a href="index.html#concat">concat</a> </li>
 <li> <a href="index.html#nop">nop</a> </li>
 <li> <a href="index.html#identity">identity</a> </li>
 <li> <a href="index.html#lambda">lambda</a> </li>
 </ul>
 <p>They can still be accessed as usual through the module after the call.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">env</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.3/manual.html#6.6">table</a></span>
         the environment to import into
         (<em>default</em> _G)
        </li>
    </ul>





</dd>
</dl>
    <h2 class="section-header "><a name="Fields"></a>Fields</h2>

    <dl class="function">
    <dt>
    <a name = "_VERSION"></a>
    <strong>_VERSION</strong>
    </dt>
    <dd>
    Module version.







</dd>
</dl>
    <h2 class="section-header has-description"><a name="Class_Iterator"></a>Class Iterator </h2>

          <div class="section-description">
          A lazy-loading Iterator.
          </div>
    <dl class="function">
    <dt>
    <a name = "Iterator.over"></a>
    <strong>Iterator.over (iterable)</strong>
    </dt>
    <dd>
    Iterate over the given <code>iterable</code>.
 <p>If <code>iterable</code> is an array, create an Iterator instance
 that returns its values one by one. If it is an
 iterator, return itself.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the values to be iterated over
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new Iterator
    </ol>




</dd>
    <dt>
    <a name = "Iterator:next"></a>
    <strong>Iterator:next ()</strong>
    </dt>
    <dd>
    Retrieve the next element from the iterator, if any.



    <h3>Returns:</h3>
    <ol>

        the next value in the sequence, or <code>nil</code> if there is none
    </ol>




</dd>
    <dt>
    <a name = "Iterator.counter"></a>
    <strong>Iterator.counter ()</strong>
    </dt>
    <dd>
    Iterate over the naturals starting at 1.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the counter
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="index.html#Iterator:take">Iterator:take</a></li>
         <li><a href="index.html#Iterator:skip">Iterator:skip</a></li>
         <li><a href="index.html#Iterator:every">Iterator:every</a></li>
    </ul>


</dd>
    <dt>
    <a name = "Iterator.range"></a>
    <strong>Iterator.range ([start=1], stop[, step=1])</strong>
    </dt>
    <dd>
    Create an integer iterator that goes from <code>start</code> to <code>stop</code>, <code>step</code>-wise.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">start</span>
            <span class="types"><span class="type">integer</span></span>
         the start of the integer range
         (<em>default</em> 1)
        </li>
        <li><span class="parameter">stop</span>
            <span class="types"><span class="type">integer</span></span>
         the end of the integer range (inclusive)
        </li>
        <li><span class="parameter">step</span>
            <span class="types"><span class="type">integer</span></span>
         the difference between consecutive elements
         (<em>default</em> 1)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#range">range</a>
    </ul>


</dd>
    <dt>
    <a name = "Iterator.from"></a>
    <strong>Iterator.from (func, is, var)</strong>
    </dt>
    <dd>
    Iterate over the function's returned values upon repeated calls.
 <p>This can effectively convert a vanilla-Lua iterator into a capital I <a href="index.html#Iterator">Iterator</a>.
 For example, <code>Iterator.from(io.lines "my_file.txt")</code> gives you a
 string iterator over the lines in a file.</p>
 <p>In general, any expression you can use in a for loop, you can wrap into an <code>Iterator.from</code>
 to get the same sequence of values in an <a href="index.html#Iterator">Iterator</a> form. For more information on iterators,
 read <a href="http://www.lua.org/pil/7.1.html">chapter 7 of Programming in Lua</a>.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">func</span>
            <span class="types"><span class="type">function</span></span>
         the function to call
        </li>
        <li><span class="parameter">is</span>
         invariant state passed to func
        </li>
        <li><span class="parameter">var</span>
         initial variable passed to func
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator.packed_from"></a>
    <strong>Iterator.packed_from (func, is, var)</strong>
    </dt>
    <dd>
    Iterate over the function's returned values (packed into a table) upon repeated calls.
 This is similar to <a href="index.html#Iterator.from">Iterator.from</a>, but instead of the created Iterator
 generating multiple return values per call, it returns them all
 packed into an array.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">func</span>
            <span class="types"><span class="type">function</span></span>
         the function to call
        </li>
        <li><span class="parameter">is</span>
         invariant state passed to func
        </li>
        <li><span class="parameter">var</span>
         initial variable passed to fund
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">iterator</span></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator.from_coroutine"></a>
    <strong>Iterator.from_coroutine (co)</strong>
    </dt>
    <dd>
    Iterate over the <code>coroutine</code>'s yielded values.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">co</span>
            <span class="types"><span class="type">thread</span></span>
         the <code>coroutine</code> to iterate
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator.clone"></a>
    <strong>Iterator.clone (iterable)</strong>
    </dt>
    <dd>
    Nondestructively return an independent iterable from the given one.
 <p>If <code>iterable</code> is an Iterator, clone it according
 to its subtype. If <code>iterable</code> is an array, then
 return itself.</p>
 <p>Please note that coroutine and iterated function call iterators
 cannot be cloned.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iterable</span>
            <span class="types"><span class="type">iterable</span></span>
         the iterable to be cloned
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">iterable</span></span>
        the clone
    </ol>




</dd>
    <dt>
    <a name = "Iterator:filter"></a>
    <strong>Iterator:filter (predicate)</strong>
    </dt>
    <dd>
    Select only values which match the predicate.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the function to evaluate for each value
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the filtering <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:map"></a>
    <strong>Iterator:map (mapping)</strong>
    </dt>
    <dd>
    Map values into new values.
 <p>Please note that at no point during iteration may
 the <code>mapping</code> function return <code>nil</code>
 as its first value.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">mapping</span>
            <span class="types"><span class="type">function</span></span>
         the function to evaluate for each value
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the mapping <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:reduce"></a>
    <strong>Iterator:reduce (reducer, initial_value)</strong>
    </dt>
    <dd>
    Collapse values into a single value.
 <p>A reducer is a function of the form
 <pre>function(accumulated_value, new_value)</pre>
 which returns the reducing or "accumulation" of
 <code>accumulated_value</code> and <code>new_value</code></p>
 <p>The definition of "reducing" is flexible, and a few common examples
 include sum and concatenation.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">reducer</span>
            <span class="types"><span class="type">reducer</span></span>
         the collapsing function
        </li>
        <li><span class="parameter">initial_value</span>
         the initial value passed to the <code>reducer</code>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the accumulation of all values
    </ol>




</dd>
    <dt>
    <a name = "Iterator:foreach"></a>
    <strong>Iterator:foreach (func)</strong>
    </dt>
    <dd>
    Apply a function to all values.
 <p>The main difference between <code><a href="index.html#Iterator:foreach">Iterator:foreach</a></code> and
 <code><a href="index.html#Iterator:map">Iterator:map</a></code> is that <code>foreach</code> ignores the
 return value(s) of its function, while map uses them and has restrictions
 on what it can return.</p>
 <p>Another important difference is that <code><a href="index.html#Iterator:map">Iterator:map</a></code>
 is a lazy evaluator, while <code><a href="index.html#Iterator:foreach">Iterator:foreach</a></code> iterates over
 its values immediately.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">func</span>
            <span class="types"><span class="type">function</span></span>
         the function to apply for each value
        </li>
    </ul>





</dd>
    <dt>
    <a name = "Iterator:last"></a>
    <strong>Iterator:last ()</strong>
    </dt>
    <dd>
    Consume the iterator and retrieve the last value it produces.



    <h3>Returns:</h3>
    <ol>

        the last value produced by the iterator, or <code>nil</code> if there was none.
    </ol>




</dd>
    <dt>
    <a name = "Iterator:take"></a>
    <strong>Iterator:take (n)</strong>
    </dt>
    <dd>
    Iterate over the <code>n</code> first values and stop.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">integer</span></span>
         amount of values to take
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:take_while"></a>
    <strong>Iterator:take_while (predicate)</strong>
    </dt>
    <dd>
    Iterate while <code>predicate</code> is <code>true</code> and stop.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the predicate to check against
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:take_last"></a>
    <strong>Iterator:take_last (n)</strong>
    </dt>
    <dd>
    Consume the iterator and produce its <code>n</code> last values in order.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">integer</span></span>
         the number of elements to capture
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code> which will produce said values
    </ol>




</dd>
    <dt>
    <a name = "Iterator:take_until"></a>
    <strong>Iterator:take_until (predicate)</strong>
    </dt>
    <dd>
    Iterate while <code>predicate</code> is <code>false</code> and stop.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the predicate to check against
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:skip"></a>
    <strong>Iterator:skip (n)</strong>
    </dt>
    <dd>
    Iterate over the values, starting at the <code>(n+1)</code>th one.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">integer</span></span>
         amount of values to skip
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:skip_while"></a>
    <strong>Iterator:skip_while (predicate)</strong>
    </dt>
    <dd>
    Iterate over the values, starting whenever <code>predicate</code> becomes <code>false</code> for the first time.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the predicate to check against
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:skip_until"></a>
    <strong>Iterator:skip_until (predicate)</strong>
    </dt>
    <dd>
    Iterate over the values, starting whenever <code>predicate</code> becomes <code>true</code> for the first time.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the predicate to check against
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:every"></a>
    <strong>Iterator:every (n)</strong>
    </dt>
    <dd>
    Take 1 value every <code>n</code>.
 <p>The first value is always taken.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">n</span>
            <span class="types"><span class="type">integer</span></span>
         one more than the number of skipped values
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the new <code><a href="index.html#Iterator">Iterator</a></code>
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#Iterator:skip">Iterator:skip</a>
    </ul>


</dd>
    <dt>
    <a name = "Iterator:any"></a>
    <strong>Iterator:any (predicate)</strong>
    </dt>
    <dd>
    Checks if any values evaluate to <code>true</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the function to evaluate for each value,
 defaults to <pre>not (value == nil or value == false)</pre>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        <code>true</code> if and only if at least one of the
 values evaluate to <code>true</code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:all"></a>
    <strong>Iterator:all (predicate)</strong>
    </dt>
    <dd>
    Checks if all values evaluate to <code>true</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         the function to evaluate for each value,
 defaults to <pre>not (value == nil or value == false)</pre>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        <code>true</code> if and only if all of the
 values evaluate to <code>true</code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:count"></a>
    <strong>Iterator:count (predicate)</strong>
    </dt>
    <dd>
    Counts how many values evaluate to <code>true</code>.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">predicate</span>
            <span class="types"><span class="type">predicate</span></span>
         function to evaluate for each value; if
 <code>nil</code>, then counts all values.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">integer</span></span>
        the number of values that match the <code>predicate</code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:zip"></a>
    <strong>Iterator:zip (other)</strong>
    </dt>
    <dd>
    Iterate over two iterables simultaneously.
 <p>This results in an Iterator with multiple values per :next() call.</p>
 <p>The new Iterator will be considered complete as soon as the one the method
 was called on (`self`) is completed, regardless of the status of `other`.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">other</span>
            <span class="types"><span class="type">iterable</span></span>
         the other iterable to zip with this one
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the resulting zipped Iterator
    </ol>




</dd>
    <dt>
    <a name = "Iterator:packed_zip"></a>
    <strong>Iterator:packed_zip (other)</strong>
    </dt>
    <dd>
    Iterate over two iterables simultaneously, giving their values as an array.
 <p>This results in an Iterator with a single value per :next() call.</p>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">other</span>
            <span class="types"><span class="type">iterable</span></span>
         the other iterable to zip with this one
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the resulting zipped Iterator
    </ol>




</dd>
    <dt>
    <a name = "Iterator:concat"></a>
    <strong>Iterator:concat (other)</strong>
    </dt>
    <dd>
    Append elements from `other` after this iterator has been exhausted.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">other</span>
            <span class="types"><span class="type">iterable</span></span>
         the iterator whose elements will be appended
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="index.html#Iterator">Iterator</a></span>
        the concatenation
    </ol>




</dd>
    <dt>
    <a name = "Iterator:to_array"></a>
    <strong>Iterator:to_array ()</strong>
    </dt>
    <dd>
    Create an array out of the <code><a href="index.html#Iterator">Iterator</a></code>'s values.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">array</span></span>
        the array of values
    </ol>




</dd>
    <dt>
    <a name = "Iterator:to_coroutine"></a>
    <strong>Iterator:to_coroutine ()</strong>
    </dt>
    <dd>
    Create a <code>coroutine</code> that yields the values.
 of the <code><a href="index.html#Iterator">Iterator</a></code>.



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">thread</span></span>
        The new <code>coroutine</code>
    </ol>




</dd>
    <dt>
    <a name = "Iterator:is_complete"></a>
    <strong>Iterator:is_complete ()</strong>
    </dt>
    <dd>
    Check whether or not the iterator is done.
 <p>Please note that even if the iterator has reached its actual last
 value, it has no way of knowing it was the last. Therefore, this function
 will only return true once the iterator returns <code>nil</code> for the
 first time.</p>



    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        <code>true</code> if the <code><a href="index.html#Iterator">Iterator</a></code>
 has iterated over all its values.
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2022-07-31 19:56:33 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
