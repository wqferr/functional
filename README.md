# functional
Functional programming utilities implemented in pure Lua.

> The motivation behind this module is, again, portability.
If you want to embed this code on a webpage, or use it in some weird
system for which a C binding wouldn't work, this project is aimed
at you.

[The docs can be found here](https://wqferr.github.io/functional/), and were
generated by [LDoc](https://github.com/stevedonovan/LDoc). This module is
published as a rock at [luarocks.org/modules/wqferr/functional](http://luarocks.org/modules/wqferr/functional).

# About
This module seeks to provide some utility functions and structures
which are too verbose in vanilla Lua, in particular with regards to iteration
and inline function definition.

The module is writen completely in vanilla Lua,
with no dependencies on external packages. This was a decision made for
portability, and has drawbacks. Since none of this was written as a C binding, it is not
as performant as it could be.

For example, [luafun](https://github.com/luafun/luafun)
is "high-performance functional programming library for Lua designed with
[LuaJIT](http://luajit.org/luajit.html)'s trace compiler in mind".
If your environment allows you to use LuaJIT and performance is a
concern, perhaps luafun will be more suited for your needs.

**The motivation behind this module is, again, portability.
If you want to embed this code on a webpage, or use it in some weird
system for which a C binding wouldn't work, this project is aimed
at you.**

## Teal
This project also includes `functional.d.tl`, which allows it to be used with
[Teal](https://github.com/teal-language/tl): a typed dialect of Lua. The Makefile
included is a workaround so LuaRocks actually installs the `.d.tl` file as well.

Teal support is not complete, however, since some functions require features not
yet stable on the Teal compiler side.

# Learning the Ropes

If this is your first time using (or even seeing) these kinds of "stream manipulating
operators" and all those other fancy words, don't worry: we'll start from the beginning.

## Iterators

Sometimes called "streams", they are just that: some... *thing* that can produce values
over time through iteration.

Let's say we want to get an array with the numbers from 1 to 10. Sounds easy?

```lua
local f = require "functional"

local my_counter = f.counter()
local my_capped_counter = my_counter:take(10)
local my_array = my_capped_counter:to_array()

print(type(my_array))
for i, v in ipairs(my_array) do
  print(i, v)
end
```

That may seem like a lot, but those three lines make sense if you think of each step
individually. Starting from the top down:

`f.counter()` is a function that creates an iterator that just counts up. Forever.
Well, this is a start, but we don't want an infinite array! We want to cut it short!

`my_counter:take(10)` will do just that: cut the previous thing short, and stop
after 10 elements have gone through this step.

The `to_array` method just collects all the items in the stream into an array. That
transforms the abstract and scary "iterator" into a more familiar face.

From that point on, it's just regular Lua: `ipairs` into printing.

## Operator Chains

Now here's the neat part: you don't have to assign each step to a new variable. We don't
even use most of them except to define the next step.

Instead, we can just collapse them all, as below:

```lua
local f = require "functional"

local my_array = f.counter()     -- my_counter
                    :take(10)    -- my_capped_counter
                    :to_array()  -- my_array
for i, v in ipairs(my_array) do
  print(i, v)
end
```

And of course, the line breaks between each step are optional: I just put them there for clarity.
In other words, you can create that 1-10 array in a single line!

What? You could've just typed `{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}`, yeah, but what about getting
an array with all numbers from 1 to 1000? You'd have to write a for loop, and for loops in Lua
are verbose.

And this is the bare-bones example: how about we try something a little more interesting?

## Filtering

Given a list of names, which ones contain the letter B? Let's assume you already have this
chunk of code:

```lua
local names = {
  "Arya",
  "Beatrice",
  "Caleb",
  "Dennis"
}

local function has_b(name)
  if name:find("[Bb]") then
    return true
  else
    return false
  end
end
```

In pure Lua, you could write something like:
```lua
local names_with_b = {}
for _, name in ipairs(names) do
  if has_b(name) then
    table.insert(names_with_b, name)
  end
end
```

Here, `has_b` is called a predicate: a simple function which returns `true` or `false` for any given name.
Predicates are especially good for filtering. Either you keep something, or you throw it out. In fact, the
whole loop is a really common pattern: `if predicate(val): keep(val)`. `functional` has the operator
`:filter` to do just that:

```lua
local names_with_b = iterate(names)
  :filter(has_b)
  :to_array()
```

Again, with line breaks for readability. Here, `iterate` just transforms an input array into an iterator,
so we can use `:filter` or any other operators directly on it.

## Mapping

Now, what if you wanted all these names in all caps? In pure Lua, you'd have to change
the core loop:

```lua
local names_with_b = {}
for _, name in ipairs(names) do
  if has_b(name) then
    table.insert(names_with_b, string.upper(name))
  end
end
```

In a functional environment, you can just add another operator. Since we're applying the same
function to all elements in a stream, we can use the `:map` operator. It transforms (or "maps")
every element in the stream to the return value of a function.

```lua
local names_with_b = iterate(names)
  :filter(has_b)
  :map(string.upper)
  :to_array()
```

## Lambdas
### What are lambdas?

If you've never heard of lambdas, you might be thinking this is some sort of "ligma" joke. It isn't.

Many languages (including Lua!) have a way to declare anonymous functions. That is, a function
that is declared "on the spot", just to be used as an argument to another function, or to be
stored in a variable. What most of these languages have that Lua lacks is a shorthand notation
for creating such functions.

In Lua, there's no getting around `function()` (plus parameters) and `end`. That's 13 characters
typed minimum for the simplest anonymous functions. As an example, here's the definition of a
function that doubles its argument:

```lua
double = function(x) return 2*x end
```

Compare that to Python:

```python
double = lambda x: 2*x
```

That's nearly half the characters, and the Lua example doesn't even declare `double` as a local.
And JavaScript's is even shorter!

```javascript
double = (x) => 2*x
```

### OK, but why does it matter?

It's perfectly fine to use vanilla Lua's notation to declare anonymous functions, and for anything
more complex than a single operation, you **should** create a proper Lua function instead of using
this library's lambdas. But for extremely short functions, it's nice to have a shortcut, both for
coding quick and dirty examples and for readability.

### Defining lambdas

The way you declare a lambda with functional is with a simple function call:

```lua
double = f.lambda "2*x"
```

Here, `x` is a predefined name for the first argument a lambda receives. There are a couple other
such aliases which this document will reference later. If you don't like that and would like
something more name agnostic, you could instead use:

```lua
double = f.lambda "2*_1"
```

Where `_1` is the first argument, `_2` would be the second, and so on.

Note that the `return` keyword is absent. It is implied that lambdas return whatever expression
is given in the string.

### Security concerns and limitations

Under the hood, `f.lambda` uses `load()` (or `loadstring()` in older versions of Lua).

**That means creating lambdas from unknown strings is a security risk.**

If you're hardcoding all lambdas, it *should* be fine. There are some checks done internally
before `load()` takes place, to prevent simple errors or na√Øve attacks. You can check the
documentation proper for the exact restrictions, but you shouldn't run into any of them with
simple functions.

### Environments

By default, a lambda function's environment is set to an empty table. That means it only has
access to its own parameters, and cannot read or write to globals or variables in the enclosing
scope of its creation. For example, the following lambda:

```lua
local constant = 3.14
local l = f.lambda "3*constant"
print(l())
```

Will print out `nil`: pi is an undefined variable from the lambda's point of view, so its value
is `nil` since it was never assigned.

You can get around this and set the desired environment for a lambda as follows:

```lua
local constant = 3.14
local l = f.lambda("3*con", {con=constant})
print(l())
```

Of course you could use (almost) any name you wish for the lambda environment variables.
In this case, we chose to distinguish the names for `con` and `constant` for the sake of clarity
for what is and isn't in the lambda scope.

### Lambda parameter aliases

The following aliases are defined for use inside any lambda:

- `v`, or `_` for `_1`
- `x`, `y`, and `z` for `_1`, `_2`, and `_3`
- `a`, `b`, ..., and `i` for `_1`, `_2`, ..., and `_9`

These aliases can all be overwritten with the environment table, **as long as its value is neither
false or nil**. Due to how the code checks for an existing `env` overwrite, `nil` and `false` would
not go through. Therefore, if you try to set `v` to `false`, for example, the lambda constructor
itself will error to avoid unexpected behavior at runtime.
